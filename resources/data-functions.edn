[
 {:db/id #db/id [:db.part/user]
  :db/ident :fn/replace-to-many
  :db/doc "Given an entity e, a to-many attribute, and a list of new values, yields a transaction that replaces the old values by new ones"
  :db/fn #db/fn {:lang "clojure"
                 :params [db eid attr new-vals]
                 :code (let [old-vals (d/q '[:find [?t ...]
                                             :in $ ?to-many-attr ?e
                                             :where [?e ?to-many-attr ?t]]
                                           db attr eid)
                             to-remove (remove (set (seq new-vals)) old-vals)]
                         (concat
                           (for [rv to-remove] [:db/retract eid attr rv])
                           (for [nv new-vals] [:db/add eid attr nv])))}}
 {:db/id #db/id [:db.part/user]
  :db/ident :fn/upsert-rev-stream
  :db/doc "The primary key of rev-stream is compound key"
  :db/fn #db/fn
  {:lang :clojure
   :params [db m]
   :code (if-let [id (ffirst
                      (d/q '[:find ?e
                             :in $ ?u ?t ?s
                             :where
                             [?e :rev-stream/stream-unique-id ?u]
                             [?e :rev-stream/writing-time ?t]
                             [?e :rev-stream/source ?s]]
                           db (:rev-stream/stream-unique-id m)
                           (:rev-stream/writing-time m)
                           (:rev-stream/source m)))]
           [(-> (dissoc m :rev-stream/stream-unique-id
                        :rev-stream/writing-time
                        :rev-stream/source)
                (assoc :db/id id))]
           [m])}}
]
